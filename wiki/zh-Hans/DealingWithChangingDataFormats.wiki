#概要 改变数据格式
= 简介 =

CRUSH 工具箱是为 应对数据格式的变化而设计的.  即使你在有足够时间改变你的代码之前得到警告, 如果能只需接受改变而不重新开发还是会更好很多.

= 检测分隔符 =

如果你的data feed 有一个可配置的字段分隔符，最好在运行时动态确定分隔字符串.  如果数据存在可以包含字母、数字、连字符和下划线字符的标题行, 你可以如下定义shell函数：

{{{
function get_file_header {
  if test -z "$1" -o ! -r "$1"; then return 1; fi
  local _cat=cat
  if test "${1: -3:3}" = ".gz" -o "${1: -2:2}" = ".Z"; then
    _cat="gunzip -c"
  fi
  $_cat "$1" | head -1
}

function get_file_delimiter {
  local header=`get_file_header $1`
  if test -z "$header"; then return 1; fi
  echo "$header" | egrep -o '[^-_a-zA-Z0-9]' | head -1
}
}}}

就像我们会在下面看到的, 分别提取标题行会很有用.  如果空格能够充当分隔符, 记着引用 所有的分隔符和标题变量的间接引用.   所有的 CRUSH 工具都会寻找环境变量 `$DELIMITER`, 如果该环境变量已经定义了, 而且如果没有命令行选项 `-d`，它就会被用作字段分隔符.  所以在你的应用程序代码中,可能会有这样的东西:

{{{
files=`findfiles -s $start_date -e $end_date -d $dir -g "*.gz"`
DELIMITER=`get_file_delimiter $files`
export DELIMITER

# [process $files here ...]
}}}


= Detecting field location =

对于数据集包含可预测值的标题行, 使用它作为元数据在运行时找到所需字段.  在 2009-01 发行版中, 所有的 CRUSH 工具在命令行下可以接受字段名作为索引.  动态确定索引在使用标准Unix工具处理数据时也是有用的.

{{{
function locate_field {
  local label="$1"
  local file="$2"
  local header=`get_file_header "$file"` || return 1
  local delim=`get_file_delimiter "$file"` || return 1
  local index=`indexof -s "$header" -d "$delim" -l "$label"`
  echo "$index"
  if test $index -eq 0; then return 1; fi
  return 0
}
}}}

这里使用 CRUSH 工具 "`index`" 来寻找指定名字的字段的位置.  这可以让你做这样的事：

{{{
aal2d access_log > access.log

DELIMITER=`get_file_delimiter access.log`
export DELIMITER
i_auth_name=`locate_field "Auth-User" access.log`
i_user_agent=`locate_field "User-Agent" access.log`

if test $i_auth_name -eq 0 -o $i_user_agent -eq 0; then
  echo "$0: required fields missing!" >&2
  exit 1 # assuming this is in a script file
fi

aggregate -p -k $i_auth_name,$i_user_agent -c 1 access.log
# equivalent to "aggregate -K Auth-User,User-Agent -c 1 access.log"

}}}

现在，如果我们对aal2d或Apache日志的输出格式进行改变，只要"Auth-User" 和 "User-Agent"字段不被取消，我们的脚本将继续工作.

----
回到 ApplicationDevelopmentWithCrush