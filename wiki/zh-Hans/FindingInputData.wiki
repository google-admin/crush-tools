#概要 定位输入数据

= 简介 =

对于定时运行的工作，你要弄清楚程序需要什么样的数据。我们经常要每天公布数据文件，让程序以特定频率运行(比如说每天、每周、每个月)，而且要处理的数据都要严格在某个范围内，或者处理所有尚未处理的数据。CRUSH 就是在这样的环境中诞生的。

= 在指定范围内寻找数据 =

在接下来的讨论中, 我们假定每天的数据源都在磁盘上, 而且这些文件名中都有日期邮戳.

`date(1)` 工具提供了计算日期范围的一个基本方法，假定他们可以以当前日期为参照定义.

{{{
date_fmt="+%Y-%m-%d"
# end processing with yesterday's data
enddate=`date -d "-1 days" "$date_fmt"`
# process a week's worth
startdate=`date -d "-6 days $enddate" "$date_fmt"`
}}}

在这里，你有一些选项.  其一就是用`dates_in_range` 遍历所有日期, 在日期的基础上建立文件名(Dates_in_rangeUserDocs).

{{{
for d in `dates_in_range -s $startdate -e $enddate`; do
  input_filename="$source_dir/$d.dat"
  # process file...
done
}}}

另一个选择是用 `findfiles` to 直接鉴别文件 (FindfilesUserDocs).

{{{
files=`findfiles -d "$source_dir" -g "*.dat" -s $startdate -e $enddate`
# process files...
}}}

但用第二种方法时, 你最好找到了尽可能多的文件.  我们延伸前一个例子：

{{{
files=`findfiles -d "$source_dir" -g "*.dat" -s $startdate -e $enddate`
n_files=`echo $files | wc -w`
n_dates=`deltadays $startdate $enddate`
if [ $n_files -ne $n_dates ]; then
  warn "incorrect number of files found: $n_files instead of $n_dates"
  exit 1
fi
# process files...
}}}

在这里我们用 `deltadays` 在指定的日期范围内出现了多少个日期 (DeltadaysUserDocs).  这样的话，数据处理的范围就可以在代码中改变或者被用户重写而不影响这部分程序.

= 寻找所有需要处理的文件 =

在寻找输入数据时的另外一种使用模式是鉴别出所有尚未处理的数据文件.  CRUSH 通过让用户保存一个日志文件来解决这个问题，这个日志文件中保存了已经被处理的数据, 然后扫描目录来寻找不再日志文件中的项. 这个工作由 `find_not_processed` 工具完成 (Find_not_processedUserDocs).

{{{
already_done_log="$WORKING_DIR/processed.log"
files=`find_not_processed -d "$source_dir" -l "$already_done_log" -g "*.dat" -p`
for f in $files; do
  # process $f...
  basename $f >> $already_done_log
done
}}}

即使这在处理的文件可以按日期定位, 当你需要让你的程序弥补错过的一天的处理时，这种模式也是有用的.

----
回到 ApplicationDevelopmentWithCrush