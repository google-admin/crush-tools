#概要 捕捉并处理错误

= 错误处理 =

正确地处理错误是编写可靠的应用程序很重要的一部分. 为了坚持错误处理而且不致使代码可读性降低, 用一些函数来处理常见的错误是值得的.

变量"`$?`"存储了最近运行结束的命令的返回值，所以它可以用来检查命令的运行情况.  使用逻辑运算符`&&` 和 `||` 时会自动使用这个变量.

{{{
. /path/to/crushlib.sh || {
  echo "$0: failed to source crushlib.sh" >&2
  exit 1
}

files=`find_not_processed -l "$logfile" -d "$source_dir" -g \*.log`
if test $? -ne 0; then
  warn "failed to locate files"
  exit 1
fi
}}}

但当处理管道时, 你要多做些工作. 在一个管道运行后, "`$?`" 通常存储了管道中最后一个元素的退出返回值. 如果管道中别的元素发生了错误,使用这个变量不能发现错误.  Bash 提供对此给出了多个选择.

 * 检查 `PIPESTATUS` 变量. 这是一个管道中所有成员退出码的数组. 如果所有的程序在成功退出时都返回 0, 你可以这样定义一个函数来处理错误:

{{{
function DIE_ON_PIPE_ERROR {
  local exit_codes="${PIPESTATUS[*]}"
  local exit_code
  for exit_code in $exit_codes; do
    if test $exit_code -ne 0; then
      warn "$*"
      exit $exit_code
    fi
  done
  return 0
}
}}}

 它可以这样用，记着在别的命令重写`PIPESTATUS`之前调用`DIE_ON_PIPE_ERROR`:

{{{
zcat $files |
  grepfield -f 1 ".+" |
  aggregate -k 1-4 -s 5 \
  > $WORKING_DIR/tmp/$$_tmpfile.log

DIE_ON_PIPE_ERROR "line $LINENO: error processing data"
}}}

 * 选中"`pipefail`"选项, 它可以让 "`$?`" 存储在管道中的最近一个非零退出码. 这个选项在Bash 版本3中加入.

{{{
set -o pipefail
# ...
zcat $files |
  grepfield -f 1 ".+" |
  aggregate -k 1-4 -s 5 \
  > $WORKING_DIR/tmp/$$_tmpfile.log

if test $? -ne 0; then
  warn "line $LINENO: error processing data"
  exit 1
fi
}}}


注意，假定非零值就是错误返回值并不很可靠. 也许最常见的例子就是 `grep(1)` 在找不到匹配时的返回值. 在此类情况下，像`DIE_ON_PIPE_ERROR`这样的程序能不能使用取决于开发人员.

这个例子不能移植到除 Bash shell 以外的 shell.  关于如何应用这些概念到你用的 shell 中，请查看你用的 shell 的手册.

----
回到 ApplicationDevelopmentWithCrush 