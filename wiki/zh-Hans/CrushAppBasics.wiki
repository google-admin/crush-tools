#概要 开发应用程序的一些基本要点

= 简介 =

使用 CRUSH 工具包编写可靠的应用程序主要是写可靠的shell脚本。这里有些建议可以帮你更好地开始。

= 一个中间类库 =

在整个探讨过程中，我们会用一系列的shell函数在开发的某些方面的应用来示例.  你可以把这些示例集中成为一个函数库，应用到你的开发中.  这些函数的源码可以在这儿得到 http://crush-tools.googlecode.com/svn/trunk/contrib/crushlib.sh

= 计划(Scheduling)注意事项 =

如果你的程序正在`cron` 或别的计划系统(scheduling system), 你首先要确认恰当地定义了程序运行环境. 你可以在这个集中的库或相关的环境变量中定义.

关于在`cron`中运行的应用程序的另外一个问题是读取绝对路径的文件往往不能成功. 如果你的程序要读写跟脚本程序在同一个文件夹的文件，比如临时文件或状态记录文件，你要使用绝对路径以避免因程序移动后运行出现的问题. 在这个中间库中，你可以

{{{
WORKING_DIR=`dirname $0`
export WORKING_DIR
}}}

和用`$WORKING_DIR` 做那些资源的完整路径.

= 错误报告 =

在计划中运行的工作，并不能总可以清楚地知道那个程序出现了错误和警告. 话不多说，我如下定义函数:

{{{
function warn {
  echo -e "$0: $*" >&2
}
}}}

这个函数可以把错误信息的处理及其上下文环境用 `cron` 发送到到邮箱里 .

= 避免同时运行一个程序的多个实例 =

如果一个程序要在某一时刻只能有一个实例运行, 一个简单的方法就是定义这样一个函数

{{{
# check whether all of a list of processes are actually alive
function verify_pid {
  if [ -z "$*" ]; then
    return 1
  fi
  nprocs=`ps -p $* | (read header; cat) | wc -l`
  if [ $nprocs -eq $# ]; then
    return 0
  fi
  return 1
}

function assert_single_instance {
  local pidfile="${1:-$0.pid}"
  if [ ! -e "$pidfile" ]; then
    echo $$ > "$pidfile" 
    return 0
  fi
  # check for stale pid file, and print warning if running from the console
  verify_pid `cat "$pidfile"` && \
    { if test -t 1; then warn "this process is already running"; fi
      exit 1
    }
  echo $$ > "$pidfile"
  return 0
}

function cleanup_pidfile {
  local exit_code=$?
  local pidfile="${1:-$0.pid}"
  if test -e "$pidfile" -a `cat "$pidfile"` -eq $$; then
    rm $pidfile
  fi
  return $exit_code
}
}}}

这样一来，要确保你的程序在某一时刻只有一个实例活动，就可以像下面一样在你的代码中引用简单地引用几行代码.

{{{
assert_single_instance
trap 'cleanup_pidfile; exit $?' EXIT TERM INT HUP QUIT
}}}

在某些情况下，这样的技巧可以应用到全局库中.

----
回到 ApplicationDevelopmentWithCrush